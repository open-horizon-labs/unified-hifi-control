name: Build

on:
  pull_request:
    branches: [master, v3]
    types: [opened, synchronize, reopened, labeled]
  push:
    branches: [v3, 'feature/**']
    tags:
      - 'v*'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      build_lms:
        description: 'Build LMS plugin'
        type: boolean
        default: false
      build_synology:
        description: 'Build Synology SPK'
        type: boolean
        default: false
      build_qnap:
        description: 'Build QNAP (x64)'
        type: boolean
        default: false
      build_qnap_arm:
        description: 'Build QNAP (arm64)'
        type: boolean
        default: false
      build_linux_arm:
        description: 'Build Linux ARM (arm64 + armv7)'
        type: boolean
        default: false
      build_macos:
        description: 'Build macOS universal'
        type: boolean
        default: false
      build_windows:
        description: 'Build Windows'
        type: boolean
        default: false
      build_docker:
        description: 'Build Docker (x64)'
        type: boolean
        default: false
      build_linux_packages:
        description: 'Build deb/rpm packages'
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # =============================================================================
  # PLAN: Centralized decision logic for what to build
  # =============================================================================
  # This job runs first (~5s) and computes which builds are needed.
  # All other jobs check plan outputs instead of duplicating condition logic.
  # Benefits: single source of truth, implicit dependency triggering, easier debugging.

  plan:
    name: Plan
    runs-on: ubuntu-latest
    outputs:
      is_release: ${{ steps.decide.outputs.is_release }}
      build_linux_arm: ${{ steps.decide.outputs.build_linux_arm }}
      build_macos: ${{ steps.decide.outputs.build_macos }}
      build_windows: ${{ steps.decide.outputs.build_windows }}
      build_lms: ${{ steps.decide.outputs.build_lms }}
      build_synology: ${{ steps.decide.outputs.build_synology }}
      build_qnap: ${{ steps.decide.outputs.build_qnap }}
      build_qnap_arm: ${{ steps.decide.outputs.build_qnap_arm }}
      build_docker: ${{ steps.decide.outputs.build_docker }}
      build_linux_packages: ${{ steps.decide.outputs.build_linux_packages }}
      version: ${{ steps.version.outputs.version }}
      git_sha: ${{ steps.version.outputs.git_sha }}
    steps:
      - name: Compute version
        id: version
        run: |
          # Version: from git tag on release or tag push, else include PR number for traceability
          if [[ "${{ github.event_name }}" == "release" ]]; then
            VERSION="${GITHUB_REF#refs/tags/v}"
          elif [[ "${{ github.event_name }}" == "push" && "$GITHUB_REF" == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF#refs/tags/v}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            VERSION="0.0.0-pr${{ github.event.pull_request.number }}"
          else
            VERSION="0.0.0-dev"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Git SHA: use PR head SHA for pull_request events (GITHUB_SHA is merge commit)
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            GIT_SHA="${{ github.event.pull_request.head.sha }}"
            GIT_SHA="${GIT_SHA:0:7}"
          else
            GIT_SHA="${GITHUB_SHA:0:7}"
          fi
          echo "git_sha=$GIT_SHA" >> $GITHUB_OUTPUT

          echo "::notice::Build version: $VERSION ($GIT_SHA)"

      - name: Decide what to build
        id: decide
        env:
          EVENT_NAME: ${{ github.event_name }}
          EVENT_ACTION: ${{ github.event.action }}
          # The label that triggered a 'labeled' event (empty for other events)
          LABEL_ADDED: ${{ github.event.label.name }}
          # Labels (only present on PRs)
          HAS_LABEL_ALL: ${{ contains(github.event.pull_request.labels.*.name, 'build:all') }}
          HAS_LABEL_LINUX_ARM: ${{ contains(github.event.pull_request.labels.*.name, 'build:linux-arm') }}
          HAS_LABEL_MACOS: ${{ contains(github.event.pull_request.labels.*.name, 'build:macos') }}
          HAS_LABEL_WINDOWS: ${{ contains(github.event.pull_request.labels.*.name, 'build:windows') }}
          HAS_LABEL_LMS: ${{ contains(github.event.pull_request.labels.*.name, 'build:lms') }}
          HAS_LABEL_LMS_MACOS: ${{ contains(github.event.pull_request.labels.*.name, 'build:lms-macos') }}
          HAS_LABEL_SYNOLOGY: ${{ contains(github.event.pull_request.labels.*.name, 'build:synology') }}
          HAS_LABEL_QNAP: ${{ contains(github.event.pull_request.labels.*.name, 'build:qnap') }}
          HAS_LABEL_QNAP_ARM: ${{ contains(github.event.pull_request.labels.*.name, 'build:qnap-arm') }}
          HAS_LABEL_DOCKER: ${{ contains(github.event.pull_request.labels.*.name, 'build:docker') }}
          HAS_LABEL_LINUX_PACKAGES: ${{ contains(github.event.pull_request.labels.*.name, 'build:linux-packages') }}
          # Inputs (only present on workflow_dispatch)
          INPUT_LINUX_ARM: ${{ inputs.build_linux_arm }}
          INPUT_MACOS: ${{ inputs.build_macos }}
          INPUT_WINDOWS: ${{ inputs.build_windows }}
          INPUT_LMS: ${{ inputs.build_lms }}
          INPUT_SYNOLOGY: ${{ inputs.build_synology }}
          INPUT_QNAP: ${{ inputs.build_qnap }}
          INPUT_QNAP_ARM: ${{ inputs.build_qnap_arm }}
          INPUT_DOCKER: ${{ inputs.build_docker }}
          INPUT_LINUX_PACKAGES: ${{ inputs.build_linux_packages }}
        run: |
          # Skip if triggered by a non-build label (e.g., arch, coderabbit)
          # Only the 'build-me' label should trigger builds via labeled event
          if [[ "$EVENT_ACTION" == "labeled" && "$LABEL_ADDED" != "build-me" ]]; then
            echo "::notice::Skipping: labeled event for '$LABEL_ADDED' (only 'build-me' triggers builds)"
            echo "### ⏭️ Skipped" >> $GITHUB_STEP_SUMMARY
            echo "Label \`$LABEL_ADDED\` added - only \`build-me\` triggers builds." >> $GITHUB_STEP_SUMMARY
            # Set all outputs to false/empty so dependent jobs skip
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "build_linux_arm=false" >> $GITHUB_OUTPUT
            echo "build_macos=false" >> $GITHUB_OUTPUT
            echo "build_windows=false" >> $GITHUB_OUTPUT
            echo "build_lms=false" >> $GITHUB_OUTPUT
            echo "build_synology=false" >> $GITHUB_OUTPUT
            echo "build_qnap=false" >> $GITHUB_OUTPUT
            echo "build_qnap_arm=false" >> $GITHUB_OUTPUT
            echo "build_docker=false" >> $GITHUB_OUTPUT
            echo "build_linux_packages=false" >> $GITHUB_OUTPUT
            echo "lms_matrix=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Helper function - returns true for release events, tag pushes, or build:all label
          should_build() {
            [[ "$EVENT_NAME" == "release" ]] && return 0
            [[ "$EVENT_NAME" == "push" && "$GITHUB_REF" == refs/tags/v* ]] && return 0
            [[ "$HAS_LABEL_ALL" == "true" ]] && return 0
            return 1
          }

          # Is this a release? (either a GitHub release event or a tag push)
          IS_RELEASE="false"
          if [[ "$EVENT_NAME" == "release" ]]; then
            IS_RELEASE="true"
          elif [[ "$EVENT_NAME" == "push" && "$GITHUB_REF" == refs/tags/v* ]]; then
            IS_RELEASE="true"
          fi
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          # Linux ARM: needed for ARM binaries, Synology ARM, QNAP ARM, linux packages
          BUILD_LINUX_ARM="false"
          if should_build; then BUILD_LINUX_ARM="true"; fi
          if [[ "$HAS_LABEL_LINUX_ARM" == "true" ]]; then BUILD_LINUX_ARM="true"; fi
          if [[ "$HAS_LABEL_SYNOLOGY" == "true" ]]; then BUILD_LINUX_ARM="true"; fi
          if [[ "$HAS_LABEL_QNAP_ARM" == "true" ]]; then BUILD_LINUX_ARM="true"; fi
          if [[ "$HAS_LABEL_LINUX_PACKAGES" == "true" ]]; then BUILD_LINUX_ARM="true"; fi
          if [[ "$INPUT_LINUX_ARM" == "true" ]]; then BUILD_LINUX_ARM="true"; fi
          if [[ "$INPUT_SYNOLOGY" == "true" ]]; then BUILD_LINUX_ARM="true"; fi
          if [[ "$INPUT_QNAP_ARM" == "true" ]]; then BUILD_LINUX_ARM="true"; fi
          if [[ "$INPUT_LINUX_PACKAGES" == "true" ]]; then BUILD_LINUX_ARM="true"; fi
          echo "build_linux_arm=$BUILD_LINUX_ARM" >> $GITHUB_OUTPUT

          # macOS: also triggered by build:lms-macos label
          BUILD_MACOS="false"
          if should_build; then BUILD_MACOS="true"; fi
          if [[ "$HAS_LABEL_MACOS" == "true" ]]; then BUILD_MACOS="true"; fi
          if [[ "$HAS_LABEL_LMS_MACOS" == "true" ]]; then BUILD_MACOS="true"; fi
          if [[ "$INPUT_MACOS" == "true" ]]; then BUILD_MACOS="true"; fi
          echo "build_macos=$BUILD_MACOS" >> $GITHUB_OUTPUT

          # Windows
          BUILD_WINDOWS="false"
          if should_build; then BUILD_WINDOWS="true"; fi
          if [[ "$HAS_LABEL_WINDOWS" == "true" ]]; then BUILD_WINDOWS="true"; fi
          if [[ "$INPUT_WINDOWS" == "true" ]]; then BUILD_WINDOWS="true"; fi
          echo "build_windows=$BUILD_WINDOWS" >> $GITHUB_OUTPUT

          # LMS Plugin: also triggered by build:lms-macos label
          BUILD_LMS="false"
          if should_build; then BUILD_LMS="true"; fi
          if [[ "$HAS_LABEL_LMS" == "true" ]]; then BUILD_LMS="true"; fi
          if [[ "$HAS_LABEL_LMS_MACOS" == "true" ]]; then BUILD_LMS="true"; fi
          if [[ "$INPUT_LMS" == "true" ]]; then BUILD_LMS="true"; fi
          echo "build_lms=$BUILD_LMS" >> $GITHUB_OUTPUT

          # Synology
          BUILD_SYNOLOGY="false"
          if should_build; then BUILD_SYNOLOGY="true"; fi
          if [[ "$HAS_LABEL_SYNOLOGY" == "true" ]]; then BUILD_SYNOLOGY="true"; fi
          if [[ "$INPUT_SYNOLOGY" == "true" ]]; then BUILD_SYNOLOGY="true"; fi
          echo "build_synology=$BUILD_SYNOLOGY" >> $GITHUB_OUTPUT

          # QNAP x64
          BUILD_QNAP="false"
          if should_build; then BUILD_QNAP="true"; fi
          if [[ "$HAS_LABEL_QNAP" == "true" ]]; then BUILD_QNAP="true"; fi
          if [[ "$INPUT_QNAP" == "true" ]]; then BUILD_QNAP="true"; fi
          echo "build_qnap=$BUILD_QNAP" >> $GITHUB_OUTPUT

          # QNAP ARM
          BUILD_QNAP_ARM="false"
          if should_build; then BUILD_QNAP_ARM="true"; fi
          if [[ "$HAS_LABEL_QNAP_ARM" == "true" ]]; then BUILD_QNAP_ARM="true"; fi
          if [[ "$INPUT_QNAP_ARM" == "true" ]]; then BUILD_QNAP_ARM="true"; fi
          echo "build_qnap_arm=$BUILD_QNAP_ARM" >> $GITHUB_OUTPUT

          # Docker x64
          BUILD_DOCKER="false"
          if should_build; then BUILD_DOCKER="true"; fi
          if [[ "$HAS_LABEL_DOCKER" == "true" ]]; then BUILD_DOCKER="true"; fi
          if [[ "$INPUT_DOCKER" == "true" ]]; then BUILD_DOCKER="true"; fi
          echo "build_docker=$BUILD_DOCKER" >> $GITHUB_OUTPUT

          # Linux packages (deb/rpm)
          BUILD_LINUX_PACKAGES="false"
          if should_build; then BUILD_LINUX_PACKAGES="true"; fi
          if [[ "$HAS_LABEL_LINUX_PACKAGES" == "true" ]]; then BUILD_LINUX_PACKAGES="true"; fi
          if [[ "$INPUT_LINUX_PACKAGES" == "true" ]]; then BUILD_LINUX_PACKAGES="true"; fi
          echo "build_linux_packages=$BUILD_LINUX_PACKAGES" >> $GITHUB_OUTPUT

          # Step summary - show label → build mapping
          echo "### Build Plan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Default:** lint, test, fullstack-check, linux-x64" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Build optional builds table directly
          HAS_OPTIONAL="false"
          TABLE_ROWS=""

          # Helper: is this a release trigger (either release event or tag push)?
          IS_RELEASE_TRIGGER="false"
          RELEASE_TRIGGER_NAME="release"
          if [[ "$EVENT_NAME" == "release" ]]; then
            IS_RELEASE_TRIGGER="true"
            RELEASE_TRIGGER_NAME="release"
          elif [[ "$EVENT_NAME" == "push" && "$GITHUB_REF" == refs/tags/v* ]]; then
            IS_RELEASE_TRIGGER="true"
            RELEASE_TRIGGER_NAME="tag"
          fi

          add_row() {
            TABLE_ROWS="${TABLE_ROWS}| $1 | $2 |"$'\n'
            HAS_OPTIONAL="true"
          }

          if [[ "$BUILD_LMS" == "true" ]]; then
            if [[ "$IS_RELEASE_TRIGGER" == "true" ]]; then add_row "lms" "$RELEASE_TRIGGER_NAME"
            elif [[ "$HAS_LABEL_LMS_MACOS" == "true" ]]; then add_row "lms" "build:lms-macos"
            elif [[ "$HAS_LABEL_LMS" == "true" ]]; then add_row "lms" "build:lms"
            fi
          fi
          if [[ "$BUILD_MACOS" == "true" ]]; then
            if [[ "$IS_RELEASE_TRIGGER" == "true" ]]; then add_row "macos" "$RELEASE_TRIGGER_NAME"
            elif [[ "$HAS_LABEL_LMS_MACOS" == "true" ]]; then add_row "macos" "build:lms-macos"
            elif [[ "$HAS_LABEL_MACOS" == "true" ]]; then add_row "macos" "build:macos"
            fi
          fi
          if [[ "$BUILD_LINUX_ARM" == "true" ]]; then
            TRIGGER="$RELEASE_TRIGGER_NAME"
            [[ "$HAS_LABEL_LINUX_ARM" == "true" ]] && TRIGGER="build:linux-arm"
            [[ "$HAS_LABEL_SYNOLOGY" == "true" ]] && TRIGGER="build:synology (implicit)"
            [[ "$HAS_LABEL_QNAP_ARM" == "true" ]] && TRIGGER="build:qnap-arm (implicit)"
            [[ "$HAS_LABEL_LINUX_PACKAGES" == "true" ]] && TRIGGER="build:linux-packages (implicit)"
            add_row "linux-arm" "$TRIGGER"
          fi
          if [[ "$BUILD_WINDOWS" == "true" ]]; then
            if [[ "$IS_RELEASE_TRIGGER" == "true" ]]; then add_row "windows" "$RELEASE_TRIGGER_NAME"
            elif [[ "$HAS_LABEL_WINDOWS" == "true" ]]; then add_row "windows" "build:windows"
            fi
          fi
          if [[ "$BUILD_SYNOLOGY" == "true" ]]; then
            if [[ "$IS_RELEASE_TRIGGER" == "true" ]]; then add_row "synology" "$RELEASE_TRIGGER_NAME"
            elif [[ "$HAS_LABEL_SYNOLOGY" == "true" ]]; then add_row "synology" "build:synology"
            fi
          fi
          if [[ "$BUILD_QNAP" == "true" ]]; then
            if [[ "$IS_RELEASE_TRIGGER" == "true" ]]; then add_row "qnap" "$RELEASE_TRIGGER_NAME"
            elif [[ "$HAS_LABEL_QNAP" == "true" ]]; then add_row "qnap" "build:qnap"
            fi
          fi
          if [[ "$BUILD_QNAP_ARM" == "true" ]]; then
            if [[ "$IS_RELEASE_TRIGGER" == "true" ]]; then add_row "qnap-arm" "$RELEASE_TRIGGER_NAME"
            elif [[ "$HAS_LABEL_QNAP_ARM" == "true" ]]; then add_row "qnap-arm" "build:qnap-arm"
            fi
          fi
          if [[ "$BUILD_DOCKER" == "true" ]]; then
            if [[ "$IS_RELEASE_TRIGGER" == "true" ]]; then add_row "docker" "$RELEASE_TRIGGER_NAME"
            elif [[ "$HAS_LABEL_DOCKER" == "true" ]]; then add_row "docker" "build:docker"
            fi
          fi
          if [[ "$BUILD_LINUX_PACKAGES" == "true" ]]; then
            if [[ "$IS_RELEASE_TRIGGER" == "true" ]]; then add_row "linux-packages" "$RELEASE_TRIGGER_NAME"
            elif [[ "$HAS_LABEL_LINUX_PACKAGES" == "true" ]]; then add_row "linux-packages" "build:linux-packages"
            fi
          fi

          if [[ "$HAS_OPTIONAL" == "true" ]]; then
            echo "**Optional builds enabled:**" >> $GITHUB_STEP_SUMMARY
            echo "| Build | Triggered by |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|--------------|" >> $GITHUB_STEP_SUMMARY
            printf "%s" "$TABLE_ROWS" >> $GITHUB_STEP_SUMMARY
          else
            echo "_No optional builds enabled. Add \`build:*\` labels then \`build-me\` to trigger._" >> $GITHUB_STEP_SUMMARY
          fi

  # =============================================================================
  # ALWAYS RUN: Lint, Test, Web Assets, Linux x64
  # =============================================================================

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Cache generated CSS
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-css.outputs.cache-hit != 'true'
        run: make css

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "native-build"
          cache-all-crates: true
          cache-on-failure: true

      - name: Check formatting
        run: cargo fmt --check

      - name: Run clippy
        run: cargo clippy -- -D warnings

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Cache generated CSS
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-css.outputs.cache-hit != 'true'
        run: make css

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "test-build"

      - name: Run tests
        env:
          SCCACHE_GHA_ENABLED: "true"
          RUSTC_WRAPPER: "sccache"
        run: cargo test --workspace

  # Build WASM assets once - shared by all platform builds
  # WASM is platform-independent, so we build once and share
  # Uses content-based caching to skip build when source unchanged
  build-wasm:
    name: Build WASM Assets
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Cache WASM build output
        id: cache-wasm
        uses: actions/cache@v5
        with:
          path: |
            target/dx/
            target/wasm32-unknown-unknown/
          # Version is baked in at compile time, but we accept stale version display
          # for PRs in exchange for cache efficiency. Releases change Cargo.toml anyway.
          # Note: Tailwind version pinned in Makefile - update cache key when upgrading
          key: wasm-v2-tw4.1.18-${{ hashFiles('**/Cargo.lock', '**/Cargo.toml', 'Dioxus.toml', 'src/**/*.rs', 'assets/**', 'src/input.css', 'public/dx-components-theme.css') }}
          restore-keys: |
            wasm-v2-

      - name: Setup Rust
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Cache Rust dependencies
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "wasm-build"
          cache-all-crates: true
          cache-on-failure: true

      - name: Cache Dioxus CLI
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        id: cache-dx
        uses: actions/cache@v5
        with:
          path: ~/.cargo/bin/dx
          key: dx-cli-0.7.3

      - name: Install Dioxus CLI
        if: steps.cache-wasm.outputs.cache-hit != 'true' && steps.cache-dx.outputs.cache-hit != 'true'
        run: cargo install dioxus-cli@0.7.3 --locked

      - name: Cache generated CSS
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        run: make css

      - name: Build WASM assets (ADR 002)
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        run: |
          # Version is fetched from server at runtime, no need to bake into WASM
          dx build --fullstack --release @client --no-default-features --features web @server --features server
          echo "Generated assets:"
          find target/dx -name "*.wasm" -o -name "*.js" | head -10

      - name: Report cache status
        run: |
          if [ "${{ steps.cache-wasm.outputs.cache-hit }}" == "true" ]; then
            echo "::notice::WASM cache hit - skipped build"
          else
            echo "::notice::WASM cache miss - built from source"
          fi

      - name: Verify WASM assets exist
        run: |
          if [ ! -d "target/dx/unified-hifi-control" ]; then
            echo "::error::WASM assets not found in target/dx/ - cache may be corrupted"
            exit 1
          fi
          echo "WASM assets found:"
          find target/dx -name "*.wasm" -o -name "*.js" | head -5

      - name: Upload WASM assets
        uses: actions/upload-artifact@v6
        with:
          name: wasm-assets
          # Only upload release web assets, not entire target/dx/ (avoids 30MB+ bloat)
          path: target/dx/unified-hifi-control/release/web/
          if-no-files-found: error
          retention-days: 1

  # Note: Web assets are now embedded in the binary (ADR 002).
  # The fullstack-check job validates the fullstack build works correctly.
  # Uses same cache as build-wasm to avoid duplicate compilation.
  fullstack-check:
    name: Fullstack Build Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Cache WASM build output
        id: cache-wasm
        uses: actions/cache@v5
        with:
          path: |
            target/dx/
            target/wasm32-unknown-unknown/
          # Same cache key as build-wasm job - shares cached artifacts
          key: wasm-v2-tw4.1.18-${{ hashFiles('**/Cargo.lock', '**/Cargo.toml', 'Dioxus.toml', 'src/**/*.rs', 'assets/**', 'src/input.css', 'public/dx-components-theme.css') }}
          restore-keys: |
            wasm-v2-

      - name: Setup Rust
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "fullstack-build"
          cache-all-crates: true
          cache-on-failure: true

      - name: Cache Dioxus CLI
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        id: cache-dx
        uses: actions/cache@v5
        with:
          path: ~/.cargo/bin/dx
          key: dx-cli-0.7.3

      - name: Install Dioxus CLI
        if: steps.cache-wasm.outputs.cache-hit != 'true' && steps.cache-dx.outputs.cache-hit != 'true'
        run: cargo install dioxus-cli@0.7.3 --locked

      - name: Cache generated CSS
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        run: make css

      - name: Build fullstack (verify WASM generation)
        if: steps.cache-wasm.outputs.cache-hit != 'true'
        # ADR 002: WASM is generated and will be embedded in the final cargo binary
        run: |
          dx build --fullstack --release @client --no-default-features --features web @server --features server
          echo "Verifying WASM assets were generated:"
          ls -la target/dx/unified-hifi-control/release/web/public/assets/ || true

      - name: Report cache status
        run: |
          if [ "${{ steps.cache-wasm.outputs.cache-hit }}" == "true" ]; then
            echo "::notice::WASM cache hit - skipped fullstack build"
          else
            echo "::notice::WASM cache miss - built from source"
          fi

      - name: Verify WASM assets exist
        run: |
          if [ ! -d "target/dx/unified-hifi-control" ]; then
            echo "::error::WASM assets not found - cache may be corrupted"
            exit 1
          fi
          echo "WASM assets verified"

  build-linux-x64:
    name: Build Linux x64
    needs: [plan, build-wasm]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-musl

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: zigbuild-x86_64-unknown-linux-musl

      - name: Install zig
        run: |
          curl -L https://ziglang.org/download/0.13.0/zig-linux-x86_64-0.13.0.tar.xz | tar -xJ
          sudo mv zig-linux-x86_64-0.13.0 /opt/zig
          echo "/opt/zig" >> $GITHUB_PATH

      - name: Cache cargo-zigbuild
        id: cache-zigbuild
        uses: actions/cache@v5
        with:
          path: ~/.cargo/bin/cargo-zigbuild
          key: cargo-zigbuild-0.20

      - name: Install cargo-zigbuild
        if: steps.cache-zigbuild.outputs.cache-hit != 'true'
        run: cargo install cargo-zigbuild --locked

      - name: Download WASM assets
        uses: actions/download-artifact@v7
        with:
          name: wasm-assets
          path: target/dx/unified-hifi-control/release/web/

      - name: Cache generated CSS
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-css.outputs.cache-hit != 'true'
        run: make css

      - name: Build with zigbuild (embeds WASM)
        env:
          UHC_VERSION: ${{ needs.plan.outputs.version }}
          UHC_GIT_SHA: ${{ needs.plan.outputs.git_sha }}
        run: |
          # Force rebuild of main crate to pick up version env vars and embedded assets
          cargo clean -p unified-hifi-control 2>/dev/null || true
          cargo zigbuild --release --target x86_64-unknown-linux-musl

      - name: Rename binary
        run: |
          mkdir -p dist/bin
          cp target/x86_64-unknown-linux-musl/release/unified-hifi-control dist/bin/unified-hifi-linux-x64

      - name: Upload binary
        uses: actions/upload-artifact@v6
        with:
          name: binary-x86_64-unknown-linux-musl
          path: dist/bin/
          retention-days: 5

  # Smoke test: verify the musl binary actually works with embedded assets
  smoke-test:
    name: Smoke Test Binary
    needs: [plan, build-linux-x64]
    runs-on: ubuntu-latest
    steps:
      - name: Download binary
        uses: actions/download-artifact@v7
        with:
          name: binary-x86_64-unknown-linux-musl
          path: dist/

      - name: Make executable
        run: chmod +x dist/unified-hifi-linux-x64

      - name: Start server
        run: |
          export RUST_BACKTRACE=1
          dist/unified-hifi-linux-x64 > /tmp/server.log 2>&1 &
          echo $! > /tmp/server.pid
          # Wait for server to be ready (max 30s)
          for i in {1..30}; do
            if curl -s http://localhost:8088/ > /dev/null 2>&1; then
              echo "Server ready after ${i}s"
              exit 0
            fi
            # Check if process died
            if ! kill -0 $(cat /tmp/server.pid) 2>/dev/null; then
              echo "Server process died!"
              echo "=== Server output ==="
              cat /tmp/server.log
              exit 1
            fi
            sleep 1
          done
          echo "Server failed to start within 30s"
          echo "=== Server output ==="
          cat /tmp/server.log
          exit 1

      - name: Verify HTTP response
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8088/)
          if [ "$STATUS" != "200" ]; then
            echo "Expected HTTP 200, got $STATUS"
            exit 1
          fi
          echo "✓ HTTP 200 OK"

      - name: Verify version injection
        env:
          EXPECTED_VERSION: ${{ needs.plan.outputs.version }}
          EXPECTED_SHA: ${{ needs.plan.outputs.git_sha }}
        run: |
          RESP=$(curl -s http://localhost:8088/status)
          echo "Status response: $RESP"

          VERSION=$(echo "$RESP" | jq -r '.version')
          GIT_SHA=$(echo "$RESP" | jq -r '.git_sha')

          echo "Expected version: $EXPECTED_VERSION, got: $VERSION"
          echo "Expected SHA: $EXPECTED_SHA, got: $GIT_SHA"

          if [ "$VERSION" != "$EXPECTED_VERSION" ]; then
            echo "::error::Version mismatch! Expected $EXPECTED_VERSION, got $VERSION"
            exit 1
          fi
          echo "✓ Version correct: $VERSION"

          if [ "$GIT_SHA" != "$EXPECTED_SHA" ]; then
            echo "::error::Git SHA mismatch! Expected $EXPECTED_SHA, got $GIT_SHA"
            exit 1
          fi
          echo "✓ Git SHA correct: $GIT_SHA"

      - name: Verify WASM assets served (ADR 002)
        run: |
          HTML=$(curl -s http://localhost:8088/)

          # Check title
          if ! echo "$HTML" | grep -q '<title>'; then
            echo "Missing <title> tag"
            exit 1
          fi
          echo "✓ HTML title present"

          # Check for WASM loader script (generated by dx build)
          if echo "$HTML" | grep -q 'assets/unified-hifi-control'; then
            echo "✓ WASM loader script present in HTML"
          else
            echo "⚠ No WASM loader script found (SSR-only mode)"
          fi

          # Check embedded CSS (style tags)
          STYLE_COUNT=$(echo "$HTML" | grep -c '<style' || echo 0)
          if [ "$STYLE_COUNT" -ge 2 ]; then
            echo "✓ $STYLE_COUNT embedded CSS stylesheets"
          else
            # CSS might be served as external files
            echo "✓ CSS present (may be external)"
          fi

          # Check JavaScript (script tags for hydration)
          if ! echo "$HTML" | grep -q '<script'; then
            echo "Missing <script> tags"
            exit 1
          fi
          echo "✓ JavaScript present"

          # Check embedded images (base64 data URLs)
          IMAGE_COUNT=$(echo "$HTML" | grep -c 'data:image' || echo 0)
          if [ "$IMAGE_COUNT" -ge 1 ]; then
            echo "✓ $IMAGE_COUNT embedded images"
          else
            echo "✓ Images present (may be served as files)"
          fi

          # Verify WASM file is served from embedded assets
          WASM_JS=$(echo "$HTML" | grep -oE 'assets/unified-hifi-control[^"]*\.js' | head -1 || true)
          if [ -n "$WASM_JS" ]; then
            echo "Testing WASM loader: /$WASM_JS"
            WASM_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:8088/$WASM_JS")
            if [ "$WASM_STATUS" = "200" ]; then
              echo "✓ WASM loader served successfully (embedded assets working)"
            else
              echo "⚠ WASM loader returned HTTP $WASM_STATUS"
            fi
          fi

          echo ""
          echo "All smoke tests passed!"

      - name: Stop server
        if: always()
        run: |
          if [ -f /tmp/server.pid ]; then
            kill $(cat /tmp/server.pid) 2>/dev/null || true
          fi

  # =============================================================================
  # OPTIONAL: Controlled by plan outputs
  # =============================================================================

  build-linux-arm:
    name: Build Linux ARM (${{ matrix.arch }})
    needs: [plan, build-wasm]
    if: needs.plan.outputs.build_linux_arm == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - target: aarch64-unknown-linux-musl
            output: unified-hifi-linux-arm64
            arch: arm64
          - target: armv7-unknown-linux-musleabihf
            output: unified-hifi-linux-armv7
            arch: armv7
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: zigbuild-${{ matrix.target }}

      - name: Install zig
        run: |
          curl -L https://ziglang.org/download/0.13.0/zig-linux-x86_64-0.13.0.tar.xz | tar -xJ
          sudo mv zig-linux-x86_64-0.13.0 /opt/zig
          echo "/opt/zig" >> $GITHUB_PATH

      - name: Cache cargo-zigbuild
        id: cache-zigbuild
        uses: actions/cache@v5
        with:
          path: ~/.cargo/bin/cargo-zigbuild
          key: cargo-zigbuild-0.20

      - name: Install cargo-zigbuild
        if: steps.cache-zigbuild.outputs.cache-hit != 'true'
        run: cargo install cargo-zigbuild --locked

      - name: Download WASM assets
        uses: actions/download-artifact@v7
        with:
          name: wasm-assets
          path: target/dx/unified-hifi-control/release/web/

      - name: Cache generated CSS
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-css.outputs.cache-hit != 'true'
        run: make css

      - name: Build with zigbuild (embeds WASM)
        env:
          UHC_VERSION: ${{ needs.plan.outputs.version }}
          UHC_GIT_SHA: ${{ needs.plan.outputs.git_sha }}
        run: |
          # Force rebuild of main crate to pick up version env vars and embedded assets
          cargo clean -p unified-hifi-control 2>/dev/null || true
          cargo zigbuild --release --target ${{ matrix.target }}

      - name: Smoke test armv7 binary
        if: matrix.target == 'armv7-unknown-linux-musleabihf'
        run: |
          sudo apt-get update && sudo apt-get install -y qemu-user-static
          qemu-arm-static ./target/${{ matrix.target }}/release/unified-hifi-control --version

      - name: Rename binary
        run: |
          mkdir -p dist/bin
          cp target/${{ matrix.target }}/release/unified-hifi-control dist/bin/${{ matrix.output }}

      - name: Upload binary
        uses: actions/upload-artifact@v6
        with:
          name: binary-${{ matrix.target }}
          path: dist/bin/
          retention-days: 5

  build-macos-x64:
    name: Build macOS (x86_64)
    needs: [plan, build-wasm]
    if: needs.plan.outputs.build_macos == 'true'
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-apple-darwin

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: macos-x64

      - name: Download WASM assets
        uses: actions/download-artifact@v7
        with:
          name: wasm-assets
          path: target/dx/unified-hifi-control/release/web/

      - name: Cache generated CSS
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-css.outputs.cache-hit != 'true'
        run: make css

      - name: Build x86_64 (embeds WASM)
        env:
          SCCACHE_GHA_ENABLED: "true"
          RUSTC_WRAPPER: "sccache"
          UHC_VERSION: ${{ needs.plan.outputs.version }}
          UHC_GIT_SHA: ${{ needs.plan.outputs.git_sha }}
        run: |
          # Force rebuild of main crate to pick up version env vars and embedded assets
          cargo clean -p unified-hifi-control 2>/dev/null || true
          cargo build --release --target x86_64-apple-darwin

      - name: Upload binary
        uses: actions/upload-artifact@v6
        with:
          name: binary-macos-x64
          path: target/x86_64-apple-darwin/release/unified-hifi-control
          retention-days: 5

  build-macos-arm64:
    name: Build macOS (arm64)
    needs: [plan, build-wasm]
    if: needs.plan.outputs.build_macos == 'true'
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: macos-arm64

      - name: Download WASM assets
        uses: actions/download-artifact@v7
        with:
          name: wasm-assets
          path: target/dx/unified-hifi-control/release/web/

      - name: Cache generated CSS
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-css.outputs.cache-hit != 'true'
        run: make css

      - name: Build aarch64 (embeds WASM)
        env:
          SCCACHE_GHA_ENABLED: "true"
          RUSTC_WRAPPER: "sccache"
          UHC_VERSION: ${{ needs.plan.outputs.version }}
          UHC_GIT_SHA: ${{ needs.plan.outputs.git_sha }}
        run: |
          # Force rebuild of main crate to pick up version env vars and embedded assets
          cargo clean -p unified-hifi-control 2>/dev/null || true
          cargo build --release --target aarch64-apple-darwin

      - name: Upload binary
        uses: actions/upload-artifact@v6
        with:
          name: binary-macos-arm64
          path: target/aarch64-apple-darwin/release/unified-hifi-control
          retention-days: 5

  build-macos-universal:
    name: Build macOS (universal)
    needs: [plan, build-macos-x64, build-macos-arm64]
    if: |
      always() &&
      needs.plan.outputs.build_macos == 'true' &&
      needs.build-macos-x64.result == 'success' &&
      needs.build-macos-arm64.result == 'success'
    runs-on: macos-latest
    steps:
      - name: Download x86_64 binary
        uses: actions/download-artifact@v7
        with:
          name: binary-macos-x64
          path: x64/

      - name: Download arm64 binary
        uses: actions/download-artifact@v7
        with:
          name: binary-macos-arm64
          path: arm64/

      - name: Create universal binary with lipo
        run: |
          mkdir -p dist/bin
          lipo -create \
            x64/unified-hifi-control \
            arm64/unified-hifi-control \
            -output dist/bin/unified-hifi-macos-universal
          file dist/bin/unified-hifi-macos-universal

      - name: Upload binary
        uses: actions/upload-artifact@v6
        with:
          name: binary-macos-universal
          path: dist/bin/
          retention-days: 5

  build-windows:
    name: Build Windows
    needs: [plan, build-wasm]
    if: needs.plan.outputs.build_windows == 'true'
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: windows

      - name: Download WASM assets
        uses: actions/download-artifact@v7
        with:
          name: wasm-assets
          path: target/dx/unified-hifi-control/release/web/

      - name: Cache generated CSS
        id: cache-css
        uses: actions/cache@v5
        with:
          path: public/tailwind.css
          key: css-v4.1.18-${{ hashFiles('src/input.css', 'src/app/pages/*.rs', 'src/app/components/*.rs') }}

      - name: Build Tailwind CSS
        if: steps.cache-css.outputs.cache-hit != 'true'
        shell: bash
        run: |
          curl -sLO https://github.com/tailwindlabs/tailwindcss/releases/download/v4.1.18/tailwindcss-windows-x64.exe
          chmod +x tailwindcss-windows-x64.exe
          ./tailwindcss-windows-x64.exe -i src/input.css -o public/tailwind.css --content "src/app/**/*.rs"

      - name: Build (embeds WASM)
        env:
          SCCACHE_GHA_ENABLED: "true"
          RUSTC_WRAPPER: "sccache"
          UHC_VERSION: ${{ needs.plan.outputs.version }}
          UHC_GIT_SHA: ${{ needs.plan.outputs.git_sha }}
        run: |
          # Force rebuild of main crate to pick up version env vars and embedded assets
          cargo clean -p unified-hifi-control 2>/dev/null || true
          cargo build --release
        shell: bash

      - name: Rename binary
        shell: bash
        run: |
          mkdir -p dist/bin
          cp target/release/unified-hifi-control.exe dist/bin/unified-hifi-win64.exe

      - name: Upload binary
        uses: actions/upload-artifact@v6
        with:
          name: binary-windows
          path: dist/bin/
          retention-days: 5

  # Universal ZIP: all platform binaries bundled
  # Uses LMS platform folder structure so findBin() works automatically
  # Note: Web assets are embedded in the binary (ADR 002), no separate assets needed
  build-lms-universal:
    name: Build LMS Plugin (universal)
    needs: [plan, build-linux-x64, build-linux-arm, build-macos-universal, build-windows]
    if: |
      always() &&
      needs.plan.outputs.build_lms == 'true' &&
      needs.build-linux-x64.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      # Download all available binaries
      - name: Download Linux x64 binary
        uses: actions/download-artifact@v7
        with:
          name: binary-x86_64-unknown-linux-musl
          path: binaries/

      - name: Download Linux ARM64 binary
        uses: actions/download-artifact@v7
        if: needs.build-linux-arm.result == 'success'
        continue-on-error: true
        with:
          name: binary-aarch64-unknown-linux-musl
          path: binaries/

      - name: Download Linux ARMv7 binary
        uses: actions/download-artifact@v7
        if: needs.build-linux-arm.result == 'success'
        continue-on-error: true
        with:
          name: binary-armv7-unknown-linux-musleabihf
          path: binaries/

      - name: Download macOS binary
        uses: actions/download-artifact@v7
        if: needs.build-macos-universal.result == 'success'
        continue-on-error: true
        with:
          name: binary-macos-universal
          path: binaries/

      - name: Download Windows binary
        uses: actions/download-artifact@v7
        if: needs.build-windows.result == 'success'
        continue-on-error: true
        with:
          name: binary-windows
          path: binaries/

      - name: Update install.xml version
        run: |
          sed -i "s|<version>[^<]*</version>|<version>${{ needs.plan.outputs.version }}</version>|" lms-plugin/install.xml

      - name: Bundle LMS plugin with all binaries
        run: |
          mkdir -p dist
          cd lms-plugin

          # Create platform-specific Bin directories (LMS findBin convention)
          # See: https://github.com/LMS-Community/slimserver/tree/public/9.1/Bin
          mkdir -p Bin/x86_64-linux
          mkdir -p Bin/aarch64-linux
          mkdir -p Bin/arm-linux
          mkdir -p Bin/darwin
          mkdir -p Bin/MSWin32-x64-multi-thread

          # Copy binaries to their platform folders
          # All use same name so LMS findBin('unified-hifi-control') works
          if [ -f ../binaries/unified-hifi-linux-x64 ]; then
            cp ../binaries/unified-hifi-linux-x64 Bin/x86_64-linux/unified-hifi-control
            chmod +x Bin/x86_64-linux/unified-hifi-control
          fi

          if [ -f ../binaries/unified-hifi-linux-arm64 ]; then
            cp ../binaries/unified-hifi-linux-arm64 Bin/aarch64-linux/unified-hifi-control
            chmod +x Bin/aarch64-linux/unified-hifi-control
          fi

          if [ -f ../binaries/unified-hifi-linux-armv7 ]; then
            cp ../binaries/unified-hifi-linux-armv7 Bin/arm-linux/unified-hifi-control
            chmod +x Bin/arm-linux/unified-hifi-control
          fi

          if [ -f ../binaries/unified-hifi-macos-universal ]; then
            cp ../binaries/unified-hifi-macos-universal Bin/darwin/unified-hifi-control
            chmod +x Bin/darwin/unified-hifi-control
          fi

          if [ -f ../binaries/unified-hifi-win64.exe ]; then
            cp ../binaries/unified-hifi-win64.exe Bin/MSWin32-x64-multi-thread/unified-hifi-control.exe
          fi

          # Note: Web assets are embedded in the binary (ADR 002)
          # No separate public/ folder needed

          # Show what we bundled
          echo "Bundled binaries:"
          find Bin -type f -name "unified-hifi-control*" | head -20

          # Create ZIP with everything
          zip -r ../dist/lms-unified-hifi-control-${{ needs.plan.outputs.version }}.zip . \
            -x "*.git*"

      - name: Repack with correct directory structure
        run: |
          cd dist
          mkdir -p repack
          unzip lms-unified-hifi-control-${{ needs.plan.outputs.version }}.zip -d repack/UnifiedHiFi
          rm lms-unified-hifi-control-${{ needs.plan.outputs.version }}.zip
          cd repack
          zip -r ../lms-unified-hifi-control-${{ needs.plan.outputs.version }}.zip UnifiedHiFi
          cd ..
          rm -rf repack

      - name: Upload LMS plugin
        uses: actions/upload-artifact@v6
        with:
          name: lms-plugin
          path: dist/lms-unified-hifi-control-*.zip
          retention-days: 5

  # =============================================================================
  # PACKAGING: Depends on binaries (web assets embedded per ADR 002)
  # =============================================================================

  # Note: Web assets are embedded in the binary (ADR 002)
  build-synology:
    name: Build Synology SPK (${{ matrix.arch }})
    needs: [plan, build-linux-x64, build-linux-arm]
    if: |
      always() &&
      needs.plan.outputs.build_synology == 'true' &&
      needs.build-linux-x64.result == 'success'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: apollolake
            cpu_arch: x86_64
            target: x86_64-unknown-linux-musl
            binary: unified-hifi-linux-x64
          - arch: rtd1296
            cpu_arch: armv8
            target: aarch64-unknown-linux-musl
            binary: unified-hifi-linux-arm64
    steps:
      - uses: actions/checkout@v6

      - name: Check if binary available
        if: matrix.target == 'aarch64-unknown-linux-musl'
        run: |
          if [[ "${{ needs.build-linux-arm.result }}" != "success" ]]; then
            echo "::warning::ARM build not available, skipping ${{ matrix.arch }}"
            exit 1
          fi

      - name: Download Linux binary
        uses: actions/download-artifact@v7
        with:
          name: binary-${{ matrix.target }}
          path: build/synology/package/

      - name: Rename binary
        run: |
          mv build/synology/package/${{ matrix.binary }} build/synology/package/unified-hifi-control
          chmod +x build/synology/package/unified-hifi-control

      - name: Update INFO file
        run: |
          sed -i "s/version=\"{{VERSION}}\"/version=\"${{ needs.plan.outputs.version }}\"/" build/synology/INFO
          sed -i "s/arch=\"{{ARCH}}\"/arch=\"${{ matrix.arch }}\"/" build/synology/INFO

      - name: Build Synology SPK
        run: |
          cd build/synology

          # Create package.tgz with binary
          tar -czf package.tgz -C package .

          # Add extractsize to INFO (package.tgz size in KB)
          EXTRACT_SIZE=$(du -k package.tgz | cut -f1)
          echo "extractsize=\"${EXTRACT_SIZE}\"" >> INFO

          # Create SPK (exclude empty WIZARD_UIFILES - optional component)
          # Naming convention: {package}-{cpu_arch}-{version}-dsm7.spk (matches Tailscale)
          mkdir -p ../../dist/installers
          SPK_NAME="unified-hifi-control-${{ matrix.cpu_arch }}-${{ needs.plan.outputs.version }}-dsm7.spk"
          tar -cvf "../../dist/installers/${SPK_NAME}" \
            INFO PACKAGE_ICON.PNG PACKAGE_ICON_256.PNG \
            package.tgz scripts conf

      - name: Upload Synology package
        uses: actions/upload-artifact@v6
        with:
          name: synology-${{ matrix.cpu_arch }}
          path: dist/installers/*.spk
          retention-days: 5

  # Note: Web assets are embedded in the binary (ADR 002)
  build-qnap-x64:
    name: Build QNAP (x64)
    needs: [plan, build-linux-x64]
    if: needs.plan.outputs.build_qnap == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Download Linux binary
        uses: actions/download-artifact@v7
        with:
          name: binary-x86_64-unknown-linux-musl
          path: dist/bin/

      - name: Make binary executable
        run: chmod +x dist/bin/*

      - name: Prepare QNAP package
        run: |
          mkdir -p qnap-build/shared
          cp dist/bin/unified-hifi-linux-x64 qnap-build/shared/unified-hifi-control
          chmod +x qnap-build/shared/unified-hifi-control
          cp build/qnap/shared/*.sh qnap-build/shared/
          chmod +x qnap-build/shared/*.sh
          cp -r build/qnap/shared/icons qnap-build/
          sed "s/{{VERSION}}/${{ needs.plan.outputs.version }}/" build/qnap/qpkg.cfg > qnap-build/qpkg.cfg
          echo '#!/bin/sh' > qnap-build/package_routines

      - name: Build QPKG with Docker
        run: |
          docker run --rm --platform linux/amd64 \
            -v "$(pwd)/qnap-build:/src" \
            -w /src \
            owncloudci/qnap-qpkg-builder@sha256:e342184e415b1df87ef00b8c1df47988ffd6a9d232a21331556067d400f06189 \
            sh -c '/usr/share/qdk2/QDK/bin/qbuild --build-dir /src/build && cp /src/build/*.qpkg /src/ && chmod 666 /src/*.qpkg'

      - name: Move QPKG to dist
        run: |
          mkdir -p dist/installers
          mv qnap-build/*.qpkg dist/installers/unified-hifi-control_${{ needs.plan.outputs.version }}_x86_64.qpkg

      - name: Upload QNAP package
        uses: actions/upload-artifact@v6
        with:
          name: qnap-x86_64
          path: dist/installers/*.qpkg
          retention-days: 5

  # Note: Web assets are embedded in the binary (ADR 002)
  build-qnap-arm:
    name: Build QNAP (arm64)
    needs: [plan, build-linux-arm]
    if: |
      always() &&
      needs.plan.outputs.build_qnap_arm == 'true' &&
      needs.build-linux-arm.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Download Linux binary
        uses: actions/download-artifact@v7
        with:
          name: binary-aarch64-unknown-linux-musl
          path: dist/bin/

      - name: Make binary executable
        run: chmod +x dist/bin/*

      - name: Prepare QNAP package
        run: |
          mkdir -p qnap-build/shared
          cp dist/bin/unified-hifi-linux-arm64 qnap-build/shared/unified-hifi-control
          chmod +x qnap-build/shared/unified-hifi-control
          cp build/qnap/shared/*.sh qnap-build/shared/
          chmod +x qnap-build/shared/*.sh
          cp -r build/qnap/shared/icons qnap-build/
          sed "s/{{VERSION}}/${{ needs.plan.outputs.version }}/" build/qnap/qpkg.cfg > qnap-build/qpkg.cfg
          echo '#!/bin/sh' > qnap-build/package_routines

      - name: Build QPKG with Docker
        run: |
          docker run --rm --platform linux/amd64 \
            -v "$(pwd)/qnap-build:/src" \
            -w /src \
            owncloudci/qnap-qpkg-builder@sha256:e342184e415b1df87ef00b8c1df47988ffd6a9d232a21331556067d400f06189 \
            sh -c '/usr/share/qdk2/QDK/bin/qbuild --build-dir /src/build && cp /src/build/*.qpkg /src/ && chmod 666 /src/*.qpkg'

      - name: Move QPKG to dist
        run: |
          mkdir -p dist/installers
          mv qnap-build/*.qpkg dist/installers/unified-hifi-control_${{ needs.plan.outputs.version }}_arm_64.qpkg

      - name: Upload QNAP package
        uses: actions/upload-artifact@v6
        with:
          name: qnap-arm_64
          path: dist/installers/*.qpkg
          retention-days: 5

  # Note: Web assets are embedded in the binary (ADR 002)
  build-docker-x64:
    name: Build Docker (x64)
    needs: [plan, build-linux-x64]
    # Only for PRs/branches - releases use build-docker-release
    if: needs.plan.outputs.build_docker == 'true' && needs.plan.outputs.is_release != 'true'
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - uses: actions/checkout@v6

      - name: Download Linux binary
        uses: actions/download-artifact@v7
        with:
          name: binary-x86_64-unknown-linux-musl
          path: binaries/

      - name: Prepare binary
        run: |
          mv binaries/unified-hifi-linux-x64 binaries/unified-hifi-linux-amd64
          chmod +x binaries/*
          ls -la binaries/

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: muness/unified-hifi-control
          tags: |
            type=ref,event=pr
            type=ref,event=branch

      - name: Build and push
        uses: docker/build-push-action@v6
        env:
          DOCKER_BUILD_RECORD_UPLOAD: false
        with:
          context: .
          file: Dockerfile.ci
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # =============================================================================
  # RELEASE ONLY: Multi-arch Docker
  # =============================================================================

  # Note: Web assets are embedded in the binary (ADR 002)
  build-docker-release:
    name: Build Docker (${{ matrix.arch }})
    needs: [plan, build-linux-x64, build-linux-arm]
    if: needs.plan.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            target: x86_64-unknown-linux-musl
            binary: unified-hifi-linux-x64
            arch: amd64
          - platform: linux/arm64
            target: aarch64-unknown-linux-musl
            binary: unified-hifi-linux-arm64
            arch: arm64
          - platform: linux/arm/v7
            target: armv7-unknown-linux-musleabihf
            binary: unified-hifi-linux-armv7
            arch: armv7
    steps:
      - uses: actions/checkout@v6

      - name: Download Linux binary
        uses: actions/download-artifact@v7
        with:
          name: binary-${{ matrix.target }}
          path: dist/

      - name: Prepare binary
        run: |
          mv dist/${{ matrix.binary }} dist/unified-hifi-control
          chmod +x dist/unified-hifi-control

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        env:
          DOCKER_BUILD_RECORD_UPLOAD: false
        with:
          context: .
          file: Dockerfile.release
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=muness/unified-hifi-control,push-by-digest=true,name-canonical=true,push=true

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v6
        with:
          name: docker-digest-${{ matrix.target }}
          path: /tmp/digests/*
          retention-days: 1

  docker-manifest:
    name: Create Docker Manifest
    needs: [plan, build-docker-release]
    if: needs.plan.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download digests
        uses: actions/download-artifact@v7
        with:
          pattern: docker-digest-*
          path: /tmp/digests
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            muness/unified-hifi-control
            muness/roon-extension-knob
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable=${{ !contains(github.ref, '-') }}

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf 'muness/unified-hifi-control@sha256:%s ' *)

      - name: Create manifest for legacy image name
        working-directory: /tmp/digests
        run: |
          TAGS=$(jq -cr '.tags | map(select(contains("roon-extension-knob"))) | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          if [ -n "$TAGS" ]; then
            docker buildx imagetools create $TAGS \
              $(printf 'muness/unified-hifi-control@sha256:%s ' *)
          fi

  # Note: Web assets are embedded in the binary (ADR 002)
  build-linux-packages:
    name: Build Linux Packages (deb/rpm)
    needs: [plan, build-linux-x64, build-linux-arm]
    if: |
      always() &&
      needs.plan.outputs.build_linux_packages == 'true' &&
      needs.build-linux-x64.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Download Linux binaries
        uses: actions/download-artifact@v7
        with:
          pattern: binary-*-linux-*
          path: dist/bin/
          merge-multiple: true

      - name: Make binaries executable
        run: chmod +x dist/bin/*

      - name: Install fpm
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby ruby-dev build-essential rpm
          sudo gem install fpm

      - name: Build deb package (x64)
        run: |
          fpm -s dir -t deb \
            -n unified-hifi-control \
            -v ${{ needs.plan.outputs.version }} \
            --description "Source-agnostic hi-fi control bridge" \
            --url "https://github.com/open-horizon-labs/unified-hifi-control" \
            --license "PolyForm Noncommercial 1.0.0" \
            -a amd64 \
            --after-install build/linux/postinst.sh \
            dist/bin/unified-hifi-linux-x64=/usr/bin/unified-hifi-control \
            build/linux/unified-hifi-control.service=/etc/systemd/system/unified-hifi-control.service

      - name: Build rpm package (x64)
        run: |
          fpm -s dir -t rpm \
            -n unified-hifi-control \
            -v ${{ needs.plan.outputs.version }} \
            --description "Source-agnostic hi-fi control bridge" \
            --url "https://github.com/open-horizon-labs/unified-hifi-control" \
            --license "PolyForm Noncommercial 1.0.0" \
            -a x86_64 \
            --after-install build/linux/postinst.sh \
            dist/bin/unified-hifi-linux-x64=/usr/bin/unified-hifi-control \
            build/linux/unified-hifi-control.service=/etc/systemd/system/unified-hifi-control.service

      - name: Build deb package (arm64)
        if: hashFiles('dist/bin/unified-hifi-linux-arm64') != ''
        run: |
          fpm -s dir -t deb \
            -n unified-hifi-control \
            -v ${{ needs.plan.outputs.version }} \
            --description "Source-agnostic hi-fi control bridge" \
            --url "https://github.com/open-horizon-labs/unified-hifi-control" \
            --license "PolyForm Noncommercial 1.0.0" \
            -a arm64 \
            --after-install build/linux/postinst.sh \
            dist/bin/unified-hifi-linux-arm64=/usr/bin/unified-hifi-control \
            build/linux/unified-hifi-control.service=/etc/systemd/system/unified-hifi-control.service

      - name: Build deb package (armv7/armhf)
        if: hashFiles('dist/bin/unified-hifi-linux-armv7') != ''
        run: |
          fpm -s dir -t deb \
            -n unified-hifi-control \
            -v ${{ needs.plan.outputs.version }} \
            --description "Source-agnostic hi-fi control bridge" \
            --url "https://github.com/open-horizon-labs/unified-hifi-control" \
            --license "PolyForm Noncommercial 1.0.0" \
            -a armhf \
            --after-install build/linux/postinst.sh \
            dist/bin/unified-hifi-linux-armv7=/usr/bin/unified-hifi-control \
            build/linux/unified-hifi-control.service=/etc/systemd/system/unified-hifi-control.service

      - name: Upload Linux packages
        uses: actions/upload-artifact@v6
        with:
          name: linux-packages
          path: |
            *.deb
            *.rpm
          retention-days: 5

  # =============================================================================
  # RELEASE ONLY: Upload to GitHub Release
  # =============================================================================

  # Note: Web assets are embedded in the binary (ADR 002)
  upload-release:
    name: Upload to Release
    needs: [plan, build-linux-x64, build-linux-arm, build-macos-universal, build-windows, build-linux-packages, build-lms-universal, build-synology, build-qnap-x64, build-qnap-arm]
    if: needs.plan.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts/

      - name: Display structure
        run: ls -R artifacts/

      - name: Flatten binaries
        run: |
          mkdir -p release
          find artifacts -name "unified-hifi-*" -type f \
            ! -name "*.js" ! -name "*.wasm" \
            -exec cp {} release/ \;
          find artifacts -name "*.deb" -type f -exec cp {} release/ \;
          find artifacts -name "*.rpm" -type f -exec cp {} release/ \;
          find artifacts -name "*.zip" -type f -exec cp {} release/ \;
          find artifacts -name "*.spk" -type f -exec cp {} release/ \;
          find artifacts -name "*.qpkg" -type f -exec cp {} release/ \;
          ls -la release/

      - name: Generate asset list
        run: |
          cat > release-assets.md << 'EOF'
          ## Download Guide

          ### Standalone Binaries
          All binaries include embedded web assets - no separate download needed.

          | Platform | File |
          |----------|------|
          | Linux x64 | `unified-hifi-linux-x64` |
          | Linux ARM64 | `unified-hifi-linux-arm64` |
          | Linux ARMv7 | `unified-hifi-linux-armv7` |
          | macOS (Universal) | `unified-hifi-macos-universal` |
          | Windows x64 | `unified-hifi-win64.exe` |

          ### Linux Packages
          - `.deb` packages for Debian/Ubuntu
          - `.rpm` packages for Fedora/RHEL

          ### NAS Packages
          - `.spk` for Synology DSM 7+
          - `.qpkg` for QNAP

          ### LMS Plugin
          - `lms-unified-hifi-control-*.zip` - Install via LMS Settings > Plugins
          EOF

      - name: Upload to release
        uses: softprops/action-gh-release@v2
        with:
          files: release/*
          append_body: true
          body_path: release-assets.md

  update-repo-xml:
    name: Update LMS repo.xml
    needs: [plan, upload-release]
    if: needs.plan.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          ref: v3

      - name: Get release version
        id: version
        run: echo "version=${GITHUB_REF_NAME#v}" >> $GITHUB_OUTPUT

      - name: Download LMS zip and compute SHA
        id: sha
        run: |
          ZIP_URL="https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/lms-unified-hifi-control-${{ steps.version.outputs.version }}.zip"
          echo "Downloading $ZIP_URL"
          curl -fSL --retry 3 --retry-delay 5 "$ZIP_URL" -o lms-plugin.zip
          FILE_SIZE=$(stat -c%s lms-plugin.zip 2>/dev/null || stat -f%z lms-plugin.zip)
          if [ "$FILE_SIZE" -lt 1024 ]; then
            echo "Error: Downloaded file too small ($FILE_SIZE bytes), expected > 1KB"
            exit 1
          fi
          SHA=$(sha1sum lms-plugin.zip | cut -d' ' -f1)
          echo "sha=$SHA" >> $GITHUB_OUTPUT

      - name: Update repo.xml
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SHA="${{ steps.sha.outputs.sha }}"
          REPO_URL="https://github.com/${{ github.repository }}"

          cat > lms-plugin/repo.xml << 'REPOXML'
          <?xml version="1.0" encoding="UTF-8"?>
          <extensions>
            <plugins>
              <plugin name="UnifiedHiFi"
                      version="VERSION_PLACEHOLDER"
                      minTarget="8.0"
                      maxTarget="*">
                <title lang="EN">Unified Hi-Fi Control</title>
                <desc lang="EN">Source-agnostic hi-fi control bridge for Roon, LMS, HQPlayer, and hardware knobs. Provides HTTP APIs, MQTT integration, and web UI for controlling your audio system from anywhere.</desc>
                <url>URL_PLACEHOLDER</url>
                <sha>SHA_PLACEHOLDER</sha>
                <creator>Muness Castle</creator>
                <link>https://forums.lyrion.org/forum/user-forums/3rd-party-hardware/1804977-roon-knob-includes-lms-support</link>
              </plugin>
            </plugins>
          </extensions>
          REPOXML

          sed -i 's/^          //' lms-plugin/repo.xml
          sed -i "s|VERSION_PLACEHOLDER|$VERSION|" lms-plugin/repo.xml
          sed -i "s|URL_PLACEHOLDER|${REPO_URL}/releases/download/v${VERSION}/lms-unified-hifi-control-${VERSION}.zip|" lms-plugin/repo.xml
          sed -i "s|SHA_PLACEHOLDER|$SHA|" lms-plugin/repo.xml

      - name: Update install.xml version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          sed -i "s|<version>[^<]*</version>|<version>$VERSION</version>|" lms-plugin/install.xml

      - name: Create PR for LMS plugin update
        id: create-pr
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: Update LMS plugin to v${{ steps.version.outputs.version }}"
          title: "chore: Update LMS plugin to v${{ steps.version.outputs.version }}"
          body: "Auto-generated PR to update LMS plugin metadata for release v${{ steps.version.outputs.version }}."
          branch: chore/lms-update-${{ steps.version.outputs.version }}
          base: v3
          add-paths: |
            lms-plugin/repo.xml
            lms-plugin/install.xml

      - name: Enable auto-merge
        if: steps.create-pr.outputs.pull-request-number
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh pr merge ${{ steps.create-pr.outputs.pull-request-number }} --squash --auto

  publish-aur:
    name: Publish to AUR
    needs: [plan, upload-release]
    if: needs.plan.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Get release version
        id: version
        run: echo "version=${GITHUB_REF_NAME#v}" >> $GITHUB_OUTPUT

      - name: Update PKGBUILD version
        run: |
          cd build/arch
          sed -i "s/^pkgver=.*/pkgver=${{ steps.version.outputs.version }}/" PKGBUILD
          sed -i "s/^pkgrel=.*/pkgrel=1/" PKGBUILD

      - name: Publish to AUR
        uses: KSXGitHub/github-actions-deploy-aur@v4.1.1
        with:
          pkgname: unified-hifi-control-bin
          pkgbuild: build/arch/PKGBUILD
          assets: |
            build/arch/unified-hifi-control.service
            build/arch/unified-hifi-control.install
          commit_username: ${{ github.actor }}
          commit_email: ${{ github.actor }}@users.noreply.github.com
          ssh_private_key: ${{ secrets.AUR_SSH_PRIVATE_KEY }}
          commit_message: "Update to v${{ steps.version.outputs.version }}"

  # =============================================================================
  # Build Summary
  # =============================================================================

  summary:
    name: Build Summary
    needs:
      - plan
      - lint
      - test
      - fullstack-check
      - build-wasm
      - build-linux-x64
      - smoke-test
      - build-linux-arm
      - build-macos-universal
      - build-windows
      - build-lms-universal
      - build-synology
      - build-qnap-x64
      - build-qnap-arm
      - build-docker-x64
      - build-docker-release
      - build-linux-packages
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts/
        continue-on-error: true

      - name: Display build summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Binaries" >> $GITHUB_STEP_SUMMARY
          echo "| Binary | Size |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|------|" >> $GITHUB_STEP_SUMMARY
          find artifacts -name 'unified-hifi-*' -type f 2>/dev/null | while read f; do
            size=$(du -h "$f" | cut -f1)
            name=$(basename "$f")
            echo "| $name | $size |" >> $GITHUB_STEP_SUMMARY
          done || echo "| (none) | - |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Packages" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Size |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------|" >> $GITHUB_STEP_SUMMARY
          find artifacts -name '*.qpkg' -o -name '*.spk' -o -name '*.zip' -o -name '*.deb' -o -name '*.rpm' 2>/dev/null | while read f; do
            size=$(du -h "$f" | cut -f1)
            name=$(basename "$f")
            echo "| $name | $size |" >> $GITHUB_STEP_SUMMARY
          done || echo "| (none) | - |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "_Add \`build:*\` labels to configure builds, then add \`build-me\` to trigger. Labels: build:lms, build:synology, build:qnap-arm, build:linux-arm, build:macos, build:windows, build:all_" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # PR Comment with Artifact Links
  # =============================================================================

  pr-comment:
    name: Post Artifact Links
    needs: [summary]
    if: always() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Post artifact links to PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const runId = context.runId;
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;

            // Get artifacts for this run
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            // Build artifact table
            let artifactTable = '';
            if (artifacts.data.artifacts.length > 0) {
              artifactTable = '| Artifact | Size |\n|----------|------|\n';
              for (const artifact of artifacts.data.artifacts) {
                const size = (artifact.size_in_bytes / 1024 / 1024).toFixed(1) + ' MB';
                artifactTable += `| ${artifact.name} | ${size} |\n`;
              }
            } else {
              artifactTable = '_No artifacts uploaded_';
            }

            const body = `### 📦 Build Artifacts

            ${artifactTable}

            [View workflow run](${runUrl}) to download artifacts.

            _Updated: ${new Date().toISOString()}_`;

            // Check if we already posted a comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.data.find(c =>
              c.user.type === 'Bot' && c.body.includes('Build Artifacts')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body
              });
            }
