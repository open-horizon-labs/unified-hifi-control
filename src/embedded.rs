//! Embedded assets for single-binary distribution (ADR 002)
//!
//! This module embeds the WASM/JS assets generated by `dx build` into the server binary,
//! enabling true single-binary distribution without requiring a separate public/ directory.
//!
//! ## Build Requirements
//!
//! For assets to be embedded, you must run `dx build` BEFORE `cargo build`:
//!
//! ```bash
//! dx build --fullstack --release @client --no-default-features --features web @server --features server
//! cargo build --release
//! ```
//!
//! During development, if the dx output folder doesn't exist, the binary will still compile
//! but won't have embedded assets. In this case, use `dx serve` for development.
//!
//! ## How It Works
//!
//! Assets are served directly from memory via custom axum handlers. We use:
//! - `serve_api_application()` for SSR + server functions (no static assets)
//! - Custom handlers for `/assets/*` and other static files
//! - The embedded `index.html` is served as the SPA shell with WASM script tags

use axum::{
    body::Body,
    http::{header, Request, StatusCode},
    response::Response,
};
use futures::future::BoxFuture;
use http_body_util::BodyExt;
use rust_embed::Embed;
use std::task::{Context, Poll};
use tower::{Layer, Service};

/// Embedded assets from dx build output.
/// The `allow_missing = true` attribute lets this compile even when the folder doesn't exist
/// (e.g., during development without running dx build first).
#[derive(Embed)]
#[folder = "target/dx/unified-hifi-control/release/web/public/"]
#[allow_missing = true]
pub struct PublicAssets;

/// Check if embedded assets are available.
/// Returns true if assets were embedded at compile time.
pub fn has_embedded_assets() -> bool {
    // If any file is present, assets are embedded
    PublicAssets::iter().next().is_some()
}

/// Get the embedded index.html content.
/// Returns None if assets weren't embedded.
pub fn get_index_html() -> Option<String> {
    PublicAssets::get("index.html").map(|file| String::from_utf8_lossy(&file.data).into_owned())
}

/// Axum handler to serve embedded assets at /assets/* paths.
/// This handles WASM, JS, and other hashed assets.
pub async fn serve_embedded_asset(
    axum::extract::Path(path): axum::extract::Path<String>,
) -> Response<Body> {
    // Files are in assets/ subfolder
    let asset_path = format!("assets/{}", path);

    match PublicAssets::get(&asset_path) {
        Some(content) => {
            let mime = mime_guess::from_path(&asset_path)
                .first_or_octet_stream()
                .to_string();

            Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_TYPE, mime)
                // Immutable cache for hashed assets
                .header(header::CACHE_CONTROL, "public, max-age=31536000, immutable")
                .body(Body::from(content.data.into_owned()))
                .unwrap_or_else(|_| Response::new(Body::empty()))
        }
        None => Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(Body::from("Asset not found"))
            .unwrap_or_else(|_| Response::new(Body::from("Asset not found"))),
    }
}

/// Axum handler to serve the embedded index.html (SPA shell with WASM script tags).
/// This is used as a fallback for client-side routing.
pub async fn serve_index_html() -> Response<Body> {
    match get_index_html() {
        Some(html) => Response::builder()
            .status(StatusCode::OK)
            .header(header::CONTENT_TYPE, "text/html; charset=utf-8")
            .body(Body::from(html))
            .unwrap_or_else(|_| Response::new(Body::empty())),
        None => Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(Body::from("index.html not embedded"))
            .unwrap_or_else(|_| Response::new(Body::from("index.html not embedded"))),
    }
}

/// Axum handler to serve other embedded static files (favicon, CSS, images).
pub async fn serve_static_file(
    axum::extract::Path(path): axum::extract::Path<String>,
) -> Response<Body> {
    match PublicAssets::get(&path) {
        Some(content) => {
            let mime = mime_guess::from_path(&path)
                .first_or_octet_stream()
                .to_string();

            Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_TYPE, mime)
                .header(header::CACHE_CONTROL, "public, max-age=3600")
                .body(Body::from(content.data.into_owned()))
                .unwrap_or_else(|_| Response::new(Body::empty()))
        }
        None => Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(Body::from("File not found"))
            .unwrap_or_else(|_| Response::new(Body::from("File not found"))),
    }
}

/// List all embedded asset paths (for debugging).
pub fn list_embedded_assets() -> Vec<String> {
    PublicAssets::iter().map(|s| s.to_string()).collect()
}

/// Extract bootstrap scripts and links from embedded index.html.
/// These are injected into SSR HTML responses to enable WASM hydration.
/// Returns the script/link tags as a string, or None if index.html isn't embedded.
pub fn extract_bootstrap_snippet() -> Option<String> {
    let index_html = get_index_html()?;

    // Extract script tags and link/preload tags, cleaning up any stray closing tags
    let mut snippets = Vec::new();

    for line in index_html.lines() {
        let trimmed = line.trim();

        // Extract script tags (the essential WASM loader)
        if trimmed.contains("<script") {
            snippets.push(trimmed.to_string());
        }
        // Extract link tags (CSS and preloads), but clean up any </head> on same line
        else if trimmed.contains("<link") {
            let cleaned = trimmed
                .replace("</head>", "")
                .replace("</body>", "")
                .replace("</html>", "");
            if !cleaned.trim().is_empty() {
                snippets.push(cleaned.trim().to_string());
            }
        }
    }

    if snippets.is_empty() {
        None
    } else {
        Some(snippets.join("\n"))
    }
}

// =============================================================================
// Bootstrap Injection Middleware
// =============================================================================
// This middleware intercepts HTML responses from SSR and injects the WASM
// bootstrap scripts, enabling the client to hydrate without a public/ directory.

/// Tower layer that injects Dioxus bootstrap scripts into SSR HTML responses.
#[derive(Clone)]
pub struct InjectDioxusBootstrapLayer {
    bootstrap: String,
}

impl InjectDioxusBootstrapLayer {
    /// Create a new layer with the given bootstrap snippet.
    pub fn new(bootstrap: String) -> Self {
        Self { bootstrap }
    }
}

impl<S> Layer<S> for InjectDioxusBootstrapLayer {
    type Service = InjectDioxusBootstrapService<S>;

    fn layer(&self, inner: S) -> Self::Service {
        InjectDioxusBootstrapService {
            inner,
            bootstrap: self.bootstrap.clone(),
        }
    }
}

/// Service that wraps another service and injects bootstrap scripts into HTML.
#[derive(Clone)]
pub struct InjectDioxusBootstrapService<S> {
    inner: S,
    bootstrap: String,
}

impl<S> Service<Request<Body>> for InjectDioxusBootstrapService<S>
where
    S: Service<Request<Body>, Response = Response<Body>> + Clone + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Send + 'static,
{
    type Response = Response<Body>;
    type Error = S::Error;
    type Future = BoxFuture<'static, Result<Response<Body>, S::Error>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, req: Request<Body>) -> Self::Future {
        let mut inner = self.inner.clone();
        let bootstrap = self.bootstrap.clone();

        Box::pin(async move {
            let res = inner.call(req).await?;

            // Only touch HTML responses
            let is_html = res
                .headers()
                .get(header::CONTENT_TYPE)
                .and_then(|v| v.to_str().ok())
                .map(|ct| ct.starts_with("text/html"))
                .unwrap_or(false);

            if !is_html {
                return Ok(res);
            }

            // Buffer body, rewrite, and return
            let (parts, body) = res.into_parts();
            let body_bytes = match body.collect().await {
                Ok(collected) => collected.to_bytes(),
                Err(_) => return Ok(Response::from_parts(parts, Body::empty())),
            };

            let mut html = String::from_utf8_lossy(&body_bytes).to_string();

            // Only inject into SSR pages (have hydration data) that don't already have bootstrap
            // The hydration data marker indicates this is a Dioxus SSR page
            if html.contains("initial_dioxus_hydration_data") && !html.contains(&bootstrap) {
                // Inject before </body> if present, otherwise append
                if let Some(idx) = html.rfind("</body>") {
                    html.insert_str(idx, &format!("\n{}\n", bootstrap));
                } else {
                    html.push_str(&format!("\n{}\n", bootstrap));
                }
            }

            let mut new_res = Response::from_parts(parts, Body::from(html));
            // Remove Content-Length since we modified the body
            new_res.headers_mut().remove(header::CONTENT_LENGTH);
            Ok(new_res)
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_has_embedded_assets_handles_missing() {
        // This should not panic even if assets aren't embedded
        let _has_assets = has_embedded_assets();
    }

    #[test]
    fn test_get_index_html_handles_missing() {
        // This should return None if assets aren't embedded, not panic
        let _index = get_index_html();
    }
}
